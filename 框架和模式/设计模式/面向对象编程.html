<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>面向对象编程</title>
</head>

<body>
    <script>
    let test = function() {
        // 属性和方法的封装
        let Book = function(id, name, price) {

            // 私有属性
            let num = 1; // 外面访问不到的属性为私有属性

            // 私有方法
            function checkId() { // 当然，这也便是外部访问不到的私有方法

            }

            // 特权方法
            this.getName = function() { // 特权的地方在于它们能有访问私有属性和私有方法的能力

            };
            this.getPrice = function() {

            };
            this.setName = function(name) {
                this.bookName = name;
            };
            this.setPrice = function() {

            };

            // 对象公有属性
            this.id = id; // 能被外部访问到的公有属性

            // 对象的公有方法
            this.copy = function() { // 

            }

            // 构造器
            this.setName(name); // 它们在实例化的时候就已经在运行了
            this.setPrice(price);
        };


        // 现在我们来看看静态的方法和属性
        // 类 静态的公有属性
        Book.isChinese = false; // 对象不能访问！！！ 

        // 类 静态的公有方法
        Book.showTime = function() {
            console.log(new Date());
        };

        // 应该在原型里面创建都能访问得到公有的方法
        Book.prototype = {
            constructor: Book, // 假如我们并不想因为字面量语法的关系丢失 constructor 指向
            who: 'zhuliminl',
            showWho: function() {
                return this.who;
            }
        };


        let book = new Book(12, '咆哮山庄', 23.23);
        console.dir(book);
        console.dir(book.isChinese); // undefined
        console.dir(Book.isChinese); // 能访问到
        console.dir(book.showWho()); // 对象总能访问到，除非遮蔽

        /**
         * 在控制台里面，我们不可能找得到 num 这个私有属性 以及 checkId 这个私有方法
         * 而且我们发现构造器里面的函数也如期在 new 的过程中如期执行了。
         * 从而给我们的对象新添了一个属性 bookName 
         * 我们的对象也无法访问后来在类的构造函数之外定义的静态的公有属性和方法
         * 而原型中的倒是可以
         */
    };



    
























    </script>
</body>

</html>
